// Variable Declaration

var clickContFullsize = '';
var checkoutSample = '';
var samplePage1ContBtn = '';
var samplePage2ContBtn = '';
var orderConfMsgID = '';
var paypalRadioBtn = '';
var scrollDownValuePaypalMob = '';
var clickPaypalRadioBtn = '';
var clickPaypalCta = '';
var clickOnContBtn = '';
var clickOnContBtnBwd = '';
var enterExPaypalEmail = '';
var enterExPaypalPassword = '';
var clickOnExPaypalLoginBtn = '';
var clickOnExPaypalSubmitBtn = '';
var scrollDownValuePaypalSubmit = '';
var clickOnPaypalConfBtn = '';
var clickExPaypalTerms = '';
var clickOnExPaypalConfBtn = '';
var scrollDownValue = '';
var clickOnPaypalConfBtnMob = '';
var clickExPaypalTermsMob = '';
var clickOnExPaypalConfBtnMob = '';
var scrollDownValueExPaypalConf = '';
var closeRandomPopup = '';
var selectDeliveryDropdown = '';
var selectDeliveryType = '';
var clickRevDetContBtn = '';
var prodcatUrl = '';
var isShoppable = '';
var clickClickAndCollectRB = '';
var clickSelectCollection = '';
var enterPostCode = '';
var clickSearchPostCode = '';
var clickMapPanel = '';
var selectAccessPoint = '';
var enterBillingFirstName = '';
var enterBillingLastName = '';
var manualAddressLink = '';
var enterBillingAddress1 = '';
var enterBillingAddress2 = '';
var enterBillingZipCode = '';
var enterBillingPhoneNo = '';
var enterBillingCity = '';
var enterBillingAddress4 = '';
var clickSaveBtn = '';
var clickOnClearPayRadioBtn = '';
var clickOnClearPayCta = '';
var scrollDownvalueClearPay = '';
var enterClearPayEmail = '';
var contClearPayEmail = '';
var enterClearPayPassword = '';
var contClearPayPassword = '';
var contClearPayConf = '';
var clickAddEngraving = '';
var selectGiftCardCheckbox = '';
var enterGiftCardNo = '';
var enterPinNo = '';
var applyGiftCard = '';
var termsAndConGiftCard = '';
var placeGiftCardOrder = '';
var invalidGiftCardMsg = '';
var selectGiftCardCheckboxRco = '';
var enterGiftCardNoRco = '';
var enterPinNoRco = '';
var placeGiftCardOrderRco = '';
var invalidGiftCardMsgRco = '';
var accReturnUserEmailID = '';
var accReturnUserPassword = '';
var accReturnUserLoginBtn = '';
var enterGuestUserNewUserID = '';
var clickGuestUserNewuserContBtn = '';
var clickOnReturnUserLink = '';
var clickOnReturnUserLinkMob = '';
var enterReturnUserID = '';
var enterReturnUserPassword = '';
var clickOnReturnUserSigninBtn = '';
var enterNewUserSignupRegPassword = '';
var newUserCreateAccountBtn = '';
var enterFirstName = '';
var enterLastName = '';
var enterPhoneNo = '';
var clickOnShipDetContBtn = '';
var clickOnOrderRevDetContBtn = '';
var clickOnNotyouBtn = '';
var accRegistrationFirstName = '';
var accRegistrationLastName = '';
var accRegisterEmailID = '';
var accRegisterPassword = '';
var accRegisterationTerms = '';
var accRegisterBtn = '';
var clickOnContBtnMob = '';
var clickOnContBtnMobRco = '';
var clickOnExPaypalBtnMob = '';
var clickOnContBtnBwdMob = '';
var addEngraveBtn = '';
var engraveFontDrpDownBox = '';
var engraveTextBox = '';
var productImageEngravedText = '';
var engraveSaveBtn = '';
var engravePreviewBtnMob = '';
var engraveSaveBtnMob = '';
var savedEngravingSection = '';
var savedEngravingText = '';
var notAvailableProductsCount = '';
var checkoutBtnID = '';
var joinNow = '';
var avedaPlusTC = '';
var clickOnTCContBtn = '';
var memberID = '';
var timeout = '';
var pollingtime = '';
var increaseTimeout = '';
var viewCartUrl = '';
var scrollValue = '';
var addToCart = '';
var emulationDevice = '';
var cookieRejectBtn = '';
var transID = '';
var createAccountBtn = '';
var newUserSignupRegTerAndCon = '';
var clickOnAccountSignoutBtn = '';
var navigateToAccountSigninUrl = '';
var clickOnAccRegNowLink = '';
var clickOnAccRegNowMobLink = '';
var enterPurePriFirstName = '';
var enterPurePriLastName = '';
var enterPurePriAddress1 = '';
var enterPurePriAddress2 = '';
var enterPurePriZipCode = '';
var enterPurePriPhoneNo = '';
var enterPurePriCity = '';
var clickPaypalTerms = '';
var loyCheckbox = '';
var fbCheckbox1 = '';
var fbCheckbox2 = '';
var fbCheckbox3 = '';
var fbCta = '';
var fbConAccount = '';
var fbEmailID = '';
var fbPassword = '';
var fbLoginBtn = '';
var fbContBtn = '';
var proUserID = '';
var proDisc = '';
var proExpDate = '';
var clickOnProDetails = '';
var clickOnMySalon = '';
var closePopUp = '';
var salonCheckbox = '';
var salonDropdown = '';
var stylistName = '';
var clickOnSubmit = '';
var testOrderUrl = '';
var sharedAdminToolUrl = '';
var poaUserEmailId = '';
var poaUserPwd = '';
var poaLoginCta = '';
var loginAsCustLnk = '';
var bcmCustEmailId = '';
var bcmCustCta = '';
var cntPBLCta = '';
var getOrderNumber;
var ordrHstPageUrl = '';
var orderNumLink = '';
var totalOrderNumLinklen = '';
var orderDetailsLink = '';
var ordHstPBLCta = '';
var acceptCta = '';
var cardNumtxtfld = '';
var expiryDatetxtfld = '';
var secCodetxtfld = '';
var cardHoldertxtfld = '';
var countrydrpdwn = '';
var selCountry = '';
var houseNumtxtfld = '';
var streetxtfld = '';
var citytxtfld = '';
var postCodetxtfld = '';
var paybtn = '';
var paymentPaidPageMsg = '';
var prodcatUrlDonation = '';
var isshoppableDonation = '';
var clickDonationAddCta = '';
var donationValueFirst = '';
var donationValueSecond = '';
var donationValueThird = '';
var confirmDonation = '';
var viewCartUrl1 = '';
var sppPageUrl = '';
var fbSocialShare = '';
var twitterSocialShare = '';
var pinterestSocialShare = '';
var fbSocialSharePage = '';
var twitterSocialSharePage = '';
var pinterestSocialSharePage = '';
var embossingPageUrl = '';
var emboseStartBtn = '';
var clickAddToGift = '';
var clickWrapandReview = '';
var embossingName = '';
var addGiftToBag = '';
var emboseChkBtn = '';
var giftWrapCheckBox = '';
var giftWrapCheckBoxAlreadyChecked = '';
var addGiftMessageCTA = '';
var giftMessageBox = '';
var invalidMessage = '';
var cancelGiftMessageCTA = '';
var deliveryCheckoutBtnId = '';
var giftWrapOptionsSec = '';
var giftWrapOptionsMessage = '';
var giftWrapOptionsEditBtn = '';
var shopBagEditBtnId = '';
var giftWrapValDelPageGitWrapSec = '';
var giftWrapTxtViewCartOrdSummSec = '';
var giftWrapValViewCartOrdSummSec = '';
var giftWrapTxtDelPageOrdSummSec = '';
var giftWrapValDelPageOrdSummSec = '';
var giftWrapTxtPayPageOrdSummSec = '';
var giftWrapValPayPageOrdSummSec = '';
var giftWrapTxtOrdConfPageOrdSummSec = '';
var giftWrapValOrdConfPageOrdSummSec = '';
var giftWrapTxtPrintPageOrdSummSec = '';
var giftWrapValPrintPageOrdSummSec = '';
var clickPrintBtnId = '';
var giftWrapTxtOrdHstPageOrdSummSec = '';
var giftWrapValOrdHstPageOrdSummSec = '';
var giftWrapPriceVal = '';
var clickCreditCardCTAId = '';
var enterOfferCode = '';
var clickOnOfferButton = '';
var validOfferMessage = '';
var actualDel = '';
var expDel = '';
var expDelType = '';
var actualDelType = '';
var billingAddressCheckBox = '';
var clickOnAddNewAddress1 = '';
var countryDropdown = '';
var enterShippingingFirstName = '';
var enterShippingLastName = '';
var enterShippingAddress1 = '';
var enterShippingAddress2 = '';
var enterShippingZipCode = '';
var enterShippingPhoneNo = '';
var enterShippingCity = '';
var intlBillingFirstName = '';
var intlBillingLastName = '';
var intlBillingPhoneNo = '';
var intlBillingAddress1 = '';
var intlBillingAddress2 = '';
var intlBillingZipCode = '';
var intlBillingCity = '';
var selectCountry = '';
var vbundlesUrl = '';
var clickOnCustomizeButton = '';
var shadeSelection = '';
var fixSelection = '';
var clickOnCreateYourKit = '';
var addToBagForVbundles = '';
var clickOnNextBtnForShade = '';
var clickOnNextBtnForFix = '';
var clickReturnUserRadioButtonMob = '';
var orderExpand = '';

// Array Declaration
var ruIds = [];
var skuIds = [];
var clickcollect = [];
var checkoutbtn = [];
var cookieReject = [];
var createAccount = [];
var clickAccountRegisterNowLink = [];
var clickAccountRegisterNowLinkMOB = [];
var clickonJoinNow = [];
var ppAddressDetails = [];
var handleSamplesPage = [];
var clickReturnUserRadioButton1 = [];
var clickReturnUserLink1 = [];
var fbCredentials = [];
var clickProDetails = [];
var clickOnSalonService = [];
var poalogindetails = [];
var clickloginAsCustLnk = [];
var clickbcmCustCTA = [];
var clickcntPBLCTA = [];
var clickordHstPBLCTA = [];
var clickacceptCTA = [];
var clickpaybtn = [];
var vsSkuIds = [];
var clickCheckoutBtn = [];
var addEmbossingGiftIntoCart = [];
var intlShippingDetails = [];
var intlBillingDetails = [];
var addVirtualBundlesToCart = [];
// var paypalCreds = [];

const feature = 'PAYMENT';

// isDiscovery = true;
// doHeal = true;
// Initialize CommonData
var CommonData = {};

const messages = {
  stepNotApplicable: 'This step is not applicable for this Brand/Locale',
  exPayPalNotAvailableMsg: 'The Express Paypal is not clickable or not visible',
  giftcardsuccessmsg: 'The Gift Card is applied successfully',
  giftcardfailmsg: 'The Gift Card is not applied as expected',
  fullsizeSamplePage:
    'There is no Full Size sample Select Page prior to login and hence this step is skipped',
  popupMsg: 'Popup did not display and hence this step is skipped',
  viewcartLoadMsg: 'View Cart Page is not loaded yet. Reloading the page...',
  clickNotYouMsg:
    'There is Click On Not You Button Options Present and hence this step is skipped',
  orderNoNotDisplayed: 'Order confirmation page does not appear',
  successMsg: 'Order placed successfully',
  errorMsg: 'Order not placed',
  regButtonClick: 'Register button is Available to click',
  accSuccessMsg: 'Account Created successfully',
  accErrorMsg: 'Account not created',
  ppSuccessMsg: 'You are an Aveda+ Member',
  ppErrorMsg: 'You are not an Aveda+ Member',
  fontSizeMsg: 'Select Font Size is not applicable for this Brand/Locale',
  noEngraveMsg: 'There is no message Engraved on Product Image',
  proSuccessMsg: 'You are a PRO Member',
  proErrorMsg: 'You are not a PRO Member',
  paymentFailure: 'Payment is not Successful',
  invalidsuccessmsg:
    'Gift Wrap is Unable to process due to Invalid(Warning) Message',
  invalidfailmsg: 'Gift Wrap is able to process with Invalid(Warning) Message',
  functionNotApplicable:
    'This function/feature is not applicable for this Brand/Locale',
  giftWrapChkBx: 'Gift Wrap Checkbox',
  giftMsg: 'Gift Message',
  giftWrap: 'Gift Wrap',
  ordSummSec: 'Order Summary section',
};

const matchCondition = true;
var t = require('taiko');
let siteDefinition, source, NullDataException;
const Helper = require('../../helpers/helper');
const Util = require('../../../../utilities/util');
const assert = require('assert');
const Hengine = require('../../../../datainterface/providers/hengine');
const gen = require('../ReUsableFunction.js');

// This file is common template for UK Region

function makeEmail() {
  var strValues = 'abcdefghijk12345678';
  var strEmail = '';
  var strTmp;
  for (let i = 0; i < 10; i++) {
    strTmp = strValues.charAt(Math.round(strValues.length * Math.random()));
    strEmail = strEmail + strTmp;
  }
  strEmail = strEmail + '@gmail' + '.com';
  return strEmail;
}

function ReturnUserID() {
  return ruIds[Math.floor(Math.random() * ruIds.length)];
}

// reinitialise steps
function reinitialize() {
  skuIds = [
    CommonData.skuId1,
    CommonData.skuId2,
    CommonData.skuId3,
    CommonData.skuId4,
    CommonData.skuId5,
  ];

  clickcollect = [
    { loc: clickClickAndCollectRB, action: 'click' },
    { loc: checkoutBtnID, action: 'click' },
  ];

  checkoutbtn = [{ loc: checkoutBtnID, action: 'tryCatchClick' }];

  cookieReject = [{ loc: cookieRejectBtn, action: 'tryCatchClick' }];

  createAccount = [
    { loc: createAccountBtn, action: 'click' },
    {
      loc: enterNewUserSignupRegPassword,
      data: CommonData.nuPassword,
      action: 'write',
    },
    { loc: newUserSignupRegTerAndCon, action: 'click' },
  ];

  clickAccountRegisterNowLink = [
    { loc: clickOnAccRegNowLink, action: 'click' },
  ];

  clickAccountRegisterNowLinkMOB = [
    { loc: clickOnAccRegNowMobLink, action: 'click' },
  ];

  clickonJoinNow = [{ loc: joinNow, action: 'click' }];

  ppAddressDetails = [
    { loc: enterPurePriFirstName, data: CommonData.firstName, action: 'write' },
    { loc: enterPurePriLastName, data: CommonData.lastName, action: 'write' },
    { loc: enterPurePriAddress1, data: CommonData.address1, action: 'write' },
    { loc: enterPurePriAddress2, data: CommonData.address2, action: 'write' },
    { loc: enterPurePriZipCode, data: CommonData.zipCode, action: 'write' },
    { loc: enterPurePriPhoneNo, data: CommonData.phone, action: 'write' },
    { loc: enterPurePriCity, data: CommonData.city, action: 'write' },
    { loc: avedaPlusTC, action: 'click' },
    { loc: clickOnTCContBtn, action: 'click' },
  ];

  handleSamplesPage = [
    { loc: checkoutSample, action: 'tryCatchClick' },
    { loc: clickContFullsize, action: 'tryCatchClick' },
    { loc: samplePage1ContBtn, action: 'tryCatchClick' },
    { loc: samplePage2ContBtn, action: 'tryCatchClick' },
  ];

  clickReturnUserRadioButton1 = [
    { loc: clickOnReturnUserLinkMob, action: 'click' },
  ];

  clickReturnUserLink1 = [{ loc: clickOnReturnUserLink, action: 'click' }];

  fbCredentials = [
    { loc: fbEmailID, data: CommonData.fbMailID, action: 'write' },
    { loc: fbPassword, data: CommonData.fbPassword, action: 'write' },
    { loc: fbLoginBtn, action: 'click' },
    { loc: fbContBtn, action: 'tryCatchClick' },
  ];

  clickProDetails = [{ loc: clickOnProDetails, action: 'tryCatchClick' }];

  clickOnSalonService = [
    { loc: clickOnMySalon, action: 'click' },
    { loc: closePopUp, action: 'tryCatchClick' },
    { loc: salonCheckbox, action: 'click' },
    {
      loc: salonDropdown,
      data: CommonData.salonAddress,
      action: 'IndexDropDownID',
    },
    { loc: stylistName, data: CommonData.stylistName, action: 'write' },
    { loc: clickOnSubmit, action: 'click' },
    { action: 'screenshot' },
  ];

  clickloginAsCustLnk = [{ loc: loginAsCustLnk, action: 'click' }];

  clickbcmCustCTA = [{ loc: bcmCustCta, action: 'click' }];

  clickcntPBLCTA = [{ loc: cntPBLCta, action: 'click' }];

  clickordHstPBLCTA = [{ loc: ordHstPBLCta, action: 'click' }];

  clickacceptCTA = [{ loc: acceptCta, action: 'click' }];

  clickpaybtn = [{ loc: paybtn, action: 'click' }];

  poalogindetails = [
    { loc: poaUserEmailId, data: CommonData.poaId, action: 'write' },
    { loc: poaUserPwd, data: CommonData.poaPwd, action: 'write' },
    { loc: poaLoginCta, action: 'click' },
  ];

  clickCheckoutBtn = [{ loc: deliveryCheckoutBtnId, action: 'click' }];

  addEmbossingGiftIntoCart = [
    { loc: emboseStartBtn, action: 'click' },
    { action: 'screenshot' },
    { loc: clickAddToGift, action: 'click' },
    { loc: clickWrapandReview, action: 'click' },
    { action: 'screenshot' },
    { loc: embossingName, data: CommonData.firstName, action: 'write' },
    { action: 'screenshot' },
    { loc: addGiftToBag, action: 'click' },
    { action: 'screenshot' },
    { loc: emboseChkBtn, action: 'click' },
    { action: 'screenshot' },
  ];

  intlShippingDetails = [
    {
      loc: enterShippingingFirstName,
      data: CommonData.firstName,
      action: 'write',
    },
    { loc: enterShippingLastName, data: CommonData.lastName, action: 'write' },
    { loc: enterShippingAddress1, data: CommonData.address1, action: 'write' },
    { loc: enterShippingAddress2, data: CommonData.address2, action: 'write' },
    { loc: enterShippingZipCode, data: CommonData.zipCode, action: 'write' },
    { loc: enterShippingPhoneNo, data: CommonData.phone, action: 'write' },
    { loc: enterShippingCity, data: CommonData.city, action: 'write' },
    { loc: billingAddressCheckBox, action: 'click' },
    { action: 'screenshot' },
    { loc: clickOnAddNewAddress1, action: 'Scrollintoview' },
    { loc: clickOnAddNewAddress1, action: 'click' },
  ];

  intlBillingDetails = [
    { loc: countryDropdown, action: 'click' },
    { loc: selectCountry, action: 'click' },
    {
      loc: intlBillingFirstName,
      data: CommonData.intlBillingFirstName,
      action: 'write',
    },
    {
      loc: intlBillingLastName,
      data: CommonData.intlBillingLastName,
      action: 'write',
    },
    {
      loc: intlBillingPhoneNo,
      data: CommonData.intlBillingPhone,
      action: 'write',
    },
    {
      loc: intlBillingAddress1,
      data: CommonData.intlBillingAddress1,
      action: 'write',
    },
    {
      loc: intlBillingAddress2,
      data: CommonData.intlBillingAddress2,
      action: 'write',
    },
    {
      loc: intlBillingZipCode,
      data: CommonData.intlBillingZipcode,
      action: 'write',
    },
    { loc: intlBillingCity, data: CommonData.intlBillingCity, action: 'write' },
  ];

  addVirtualBundlesToCart = [
    { loc: clickOnCustomizeButton, action: 'click' },
    { action: 'screenshot' },
    { loc: shadeSelection, action: 'click' },
    { action: 'screenshot' },
    { loc: clickOnNextBtnForShade, action: 'click' },
    { loc: fixSelection, action: 'click' },
    { action: 'screenshot' },
    { loc: clickOnNextBtnForFix, action: 'click' },
    { loc: clickOnCreateYourKit, action: 'click' },
    { loc: addToBagForVbundles, action: 'click' },
    { action: 'screenshot' },
  ];

  // paypalCreds = [
  //   {
  //     loc: enterExPaypalEmail,
  //     data: CommonData.expressPayPalEmail,
  //     action: 'write',
  //   },
  //   { action: 'screenshot' },
  //   { loc: clickOnExPaypalLoginBtn, action: 'click' },
  //   {
  //     loc: enterExPaypalPassword,
  //     data: CommonData.expressPaypalPassword,
  //     action: 'write',
  //   },
  //   { action: 'screenshot' },
  //   { loc: clickOnExPaypalLoginBtn, action: 'click' },
  //   { loc: clickOnExPaypalSubmitBtn, data: 3000, action: 'Waitfor' },
  //   { loc: clickOnExPaypalSubmitBtn, action: 'click' },
  //   { action: 'screenshot' },
  // ];

  vsSkuIds = [
    CommonData.vsSkuId1,
    CommonData.vsSkuId2,
    CommonData.vsSkuId3,
    CommonData.vsSkuId4,
    CommonData.vsSkuId5,
  ];

  ruIds = [
    CommonData.ruId,
    CommonData.ruId1,
    CommonData.ruId2,
    CommonData.ruId3,
    CommonData.ruId4,
    CommonData.ruId5,
    CommonData.ruId6,
    CommonData.ruId7,
    CommonData.ruId8,
    CommonData.ruId9,
    CommonData.ruId10,
    CommonData.ruId11,
    CommonData.ruId12,
    CommonData.ruId13,
  ];
}

async function initFrameworkSettings() {
  // This should come from Gauge Tags inputs
  let tags = process.env.tags.split(',');
  ({ siteDefinition, source, NullDataException } = await Hengine.Initializer(
    tags,
    feature,
    this
  ));
  // Abort, if there is any error while setting up the locators and test data
  if (NullDataException.isError) {
    assert(!matchCondition, NullDataException.message.join('\n'));
  }

  // Override this
  Object.assign(this, source);
  // Taiko API overrides
  t = await Helper.initAutoHeal(siteDefinition, t);

  // Re-initialize variables
  reinitialize();

  // Delete all the cookies
  await t.deleteCookies();

  gauge.message('ENVIRONMENT : ' + siteDefinition.executionContext.environment);
}

async function fullsizesamplepage() {
  if (clickContFullsize !== '') {
    try {
      await t.evaluate(await t.$(clickContFullsize), (ele) => ele.click());
    } catch (e) {
      gauge.message(messages.fullsizeSamplePage);
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function reloadviewcart() {
  await t.goto(siteDefinition.executionContext.url + viewCartUrl1, {
    waitForEvents: ['DOMContentLoaded'],
  });
}

async function randompopupreg() {
  await t.waitFor(timeout);
  if (closeRandomPopup !== '') {
    try {
      await t.click(await t.$(closeRandomPopup));
    } catch (e) {
      gauge.message(messages.popupMsg);
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function addtocart() {
  for (let i = 0; i < skuIds.length; i++) {
    await t.goto(
      siteDefinition.executionContext.adminUrl + prodcatUrl + skuIds[i],
      {
        waitForEvents: ['DOMContentLoaded'],
      }
    );
    gauge.screenshot();
    if (await (await t.$(isShoppable)).exists()) {
      const isShoppableValue = await (await t.$(isShoppable)).text();
      if (isShoppableValue === '1') {
        gauge.message(
          'The Product with SKU ID - ' +
            skuIds[i] +
            ' is available and proceeding to add to Cart'
        );
        if (
          siteDefinition.executionContext.environment.toUpperCase() ===
            'PROD' ||
          siteDefinition.executionContext.environment.toUpperCase() ===
            'PREPROD'
        ) {
          await t.evaluate(await t.$(addToCart), (ele) => ele.click(), {
            waitForNavigation: false,
          });
          for (i = 0; i <= 2; i++) {
            if (
              !(await (
                await t.$(checkoutBtnID)
              ).exists(pollingtime, increaseTimeout))
            ) {
              gauge.message(messages.viewcartLoadMsg);
              await gen.ElementAction(cookieReject);
              await t.reload();
              await t.waitFor(await t.$(checkoutBtnID), increaseTimeout);
            } else {
              break;
            }
          }
        } else {
          const elements = await (await t.$(addToCart)).elements();
          const attributePromises = elements.map((e) => {
            return t.evaluate(e, (elem) => {
              return elem.getAttribute('href');
            });
          });
          viewCartUrl = await Promise.all(attributePromises);
          await t.goto(siteDefinition.executionContext.url + viewCartUrl, {
            waitForEvents: ['DOMContentLoaded'],
          });
          gauge.screenshot();
        }
        break;
      } else {
        gauge.message(
          'The Product with SKU ID - ' +
            skuIds[i] +
            ' is NOT available for adding it to Cart '
        );
        notAvailableProductsCount++;
      }
    } else {
      gauge.message(skuIds[i] + ' is not a valid SKU ID');
    }
  }
  if (notAvailableProductsCount === skuIds.length) {
    assert(
      !matchCondition,
      'None of the products are available for adding it to Cart'
    );
  }
}

async function clickpaypalRBandCTA() {
  // clicking on paypal radio Button, only for paypal payment
  // Below logic used for RCO implemented sites
  if (clickPaypalRadioBtn !== '') {
    await t.evaluate(
      await t.$(clickPaypalRadioBtn, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    gauge.screenshot();
    await t.waitFor(timeout);
    // await t.focus(await t.$(clickPaypalRadioBtn));
    // await t.press(['Tab', 'Tab', 'Enter']);
    await t.evaluate(
      await t.$(clickPaypalCta, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.waitFor(timeout); // added static timeout to handle lower environments
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  // Below logic is used for Non RCO sites
  if (paypalRadioBtn !== '') {
    await t.scrollDown(parseInt(scrollDownValuePaypalMob, scrollValue));
    await t.evaluate(
      await t.$(paypalRadioBtn, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.waitFor(increaseTimeout);
    await t.evaluate(
      await t.$(clickPaypalTerms, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.press(['Tab', 'Enter']);
    gauge.screenshot();
  }
}

// clicking on express paypal CTA on view cart for PC
async function clickexpaypalCTA() {
  await t.waitFor(timeout); // added static timeout to handle lower environments
  // Some brands work with press method and some with click methods
  if (clickOnContBtn !== '') {
    await t.focus(await t.$(clickOnContBtn));
    await t.press(['Tab', 'Enter']);
    gauge.screenshot();
  }
  if (clickOnContBtnBwd !== '') {
    await t.focus(await t.$(clickOnContBtnBwd));
    await t.press(['Shift', 'Tab', 'Enter']);
    gauge.screenshot();
  } else {
    gauge.message(messages.exPayPalNotAvailableMsg);
  }
}

// clicking on express paypal CTA on view cart for Mobile
async function clickexpaypalMOBCTA() {
  await t.waitFor(timeout); // added static wait to handle lower environments
  // Some brands work with press method and some with click methods
  if (clickOnContBtnMob !== '') {
    await t.focus(await t.$(clickOnContBtnMob));
    await t.press(['Tab', 'Enter']);
    gauge.screenshot();
  }

  // below if loop newly added for RCO implemented site to click on expayapal CTA on view cart on mobile.
  if (clickOnContBtnMobRco !== '') {
    await t.click(await t.$(clickOnContBtnMobRco));
    await t.press(['Tab', 'Enter']);
    await t.waitFor(timeout);
    await t.press(['Tab', 'Enter']);
    gauge.screenshot();
  }
  if (clickOnContBtnBwdMob !== '') {
    await t.focus(await t.$(clickOnContBtnBwdMob));
    await t.press(['Tab', 'Enter']);
    gauge.screenshot();
  }
  if (clickOnExPaypalBtnMob !== '') {
    if (
      await (
        await t.$(clickOnExPaypalBtnMob)
      ).exists(pollingtime, increaseTimeout)
    ) {
      await t.evaluate(await t.$(clickOnExPaypalBtnMob), (ele) => {
        ele.focus();
        ele.click();
      });
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.exPayPalNotAvailableMsg);
  }
}

async function paypalcredentials() {
  // Enter the paypal/express paypal mail id
  // if (enterExPaypalEmail !== '') {
  if (await (await t.$(enterExPaypalEmail)).exists(timeout)) {
    // await t.waitFor(5000);
    await t.write(
      CommonData.expressPayPalEmail,
      t.into(await t.$(enterExPaypalEmail))
    );
  }
  await t.evaluate(
    await t.$(clickOnExPaypalLoginBtn, {
      waitForEvents: ['loadEventFired'],
    }),
    (ele) => ele.click()
  );
  if (await (await t.$(enterExPaypalPassword)).exists(timeout)) {
    await t.write(
      CommonData.expressPaypalPassword,
      t.into(await t.$(enterExPaypalPassword))
    );
  }
  await t.evaluate(
    await t.$(clickOnExPaypalLoginBtn, {
      waitForEvents: ['loadEventFired'],
    }),
    (ele) => ele.click()
  );
  await t.evaluate(
    await t.$(clickOnExPaypalSubmitBtn, {
      waitForEvents: ['loadEventFired'],
    }),
    (ele) => ele.click()
  );
  await t.waitFor(9000);
}

// click on express paypal confirm button for PC
async function expaypalconfbtnpc() {
  if (
    clickOnPaypalConfBtn !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.waitFor(increaseTimeout);
    await t.scrollDown(parseInt(scrollDownValue, scrollValue));
    await t.evaluate(
      await t.$(clickOnPaypalConfBtn, {
        waitForEvents: ['loadEventFired'],
      }),
      (ele) => ele.click()
    );
    gauge.screenshot();
    await t.waitFor(timeout); // added static wait to handle lower environments
  }
  if (
    clickOnExPaypalConfBtn !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.waitFor(increaseTimeout);
    await t.scrollDown(parseInt(scrollDownValue), scrollValue);
    await t.evaluate(
      await t.$(clickExPaypalTerms, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.press(['Tab', 'Enter']);
    gauge.screenshot();
    await t.waitFor(timeout); // added static wait to handle lower environments
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

// click on express paypal confirm button for Mob
async function expaypalconfbtnmob() {
  if (
    clickOnPaypalConfBtnMob !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.scrollDown(parseInt(scrollDownValueExPaypalConf), scrollValue);
    await t.evaluate(
      await t.$(clickOnPaypalConfBtnMob, {
        waitForEvents: ['loadEventFired'],
      }),
      (ele) => ele.click()
    );
    gauge.screenshot();
    await t.waitFor(timeout); // adding static timeout to handle lower environments
  }
  if (
    clickOnExPaypalConfBtnMob !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.scrollDown(parseInt(scrollDownValueExPaypalConf, scrollValue));
    await t.evaluate(
      await t.$(clickExPaypalTermsMob, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.press(['Tab', 'Enter']);
    await t.waitFor(timeout); // adding static timeout to handle lower environments
    gauge.screenshot();
    await t.waitFor(timeout); // adding static timeout to handle lower environments
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

// selecting delivery type from dropdown in viewcart
async function deliverytype(DeliveryType) {
  if (selectDeliveryDropdown !== '') {
    const delMethods = [];
    const tmpValues = await t
      .dropDown({
        name: selectDeliveryDropdown,
      })
      .options();
    for (let i = 0; i < tmpValues.length; i++) {
      const tmp = {
        value: tmpValues[i],
        deliveryType: await (
          await t.$(selectDeliveryType + tmpValues[i] + ']')
        ).text(),
      };
      delMethods.push(tmp);
    }
    const indexDelType = delMethods.indexOf(
      delMethods.find((obj) => obj.deliveryType.includes(DeliveryType))
    );
    await t.dropDown({ name: selectDeliveryDropdown }).select({
      index: indexDelType,
    });

    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

// review details continue button
async function revdetailscontinuebtn() {
  if (
    clickRevDetContBtn !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.evaluate(await t.$(clickRevDetContBtn), (ele) => ele.click());
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function addengraveproduct() {
  if (clickAddEngraving !== '') {
    await t.goto(
      siteDefinition.executionContext.adminUrl +
        prodcatUrl +
        CommonData.engravingProductSkuId,
      { waitForEvents: ['DOMContentLoaded'] }
    );
    if (await (await t.$(isShoppable)).exists()) {
      const isShoppableValue = await (await t.$(isShoppable)).text();
      if (isShoppableValue === '1') {
        gauge.message(
          'The Product with SKU ID - ' +
            CommonData.engravingProductSkuId +
            ' is available and proceeding to add to Cart'
        );
        const elements = await (
          await t.$("//a[contains(text(),'Add to Cart')]")
        ).elements();
        const attributePromises = elements.map((e) => {
          return t.evaluate(e, (elem) => {
            return elem.getAttribute('href');
          });
        });
        viewCartUrl = await Promise.all(attributePromises);
        await t.goto(siteDefinition.executionContext.url + viewCartUrl, {
          waitForEvents: ['DOMContentLoaded'],
        });
        gauge.screenshot();
      } else {
        gauge.message(
          'The Product with SKU ID - ' +
            CommonData.engravingProductSkuId +
            ' is NOT available for adding it to Cart '
        );
      }
    } else {
      gauge.message(
        CommonData.engravingProductSkuId + ' is not a valid SKU ID'
      );
    }
  }
}

async function addengravetext() {
  // Clicking on Engrave button
  if (addEngraveBtn !== '') {
    await t.waitFor(timeout);
    await t.evaluate(await t.$(addEngraveBtn), (ele) => {
      ele.focus();
      ele.click();
    });
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  // Entering an Engrave message on Engrave Text box
  if (engraveFontDrpDownBox !== '') {
    await t
      .dropDown({ class: engraveFontDrpDownBox })
      .select(CommonData.engrFont);
    gauge.screenshot();
  } else {
    gauge.message(messages.fontSizeMsg);
  }
  if (engraveTextBox !== '') {
    await t.evaluate(await t.$(engraveTextBox), (ele) => {
      ele.focus();
      ele.click();
    });
    await t.write(
      CommonData.engrMsg,
      t.into(await t.$(engraveTextBox), { delay: pollingtime })
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  if (productImageEngravedText !== '') {
    if (await (await t.$(productImageEngravedText)).exists()) {
      const EngravedTextOnProductImage = await (
        await t.$(productImageEngravedText)
      ).text();
      if (EngravedTextOnProductImage === CommonData.engrMsg) {
        assert(matchCondition);
        gauge.message(
          'Engraved message is correct: ' + EngravedTextOnProductImage
        );
        gauge.screenshot();
      } else {
        assert(!matchCondition);
        gauge.message(
          'Engraved message is not correct: ' + EngravedTextOnProductImage
        );
      }
    } else {
      gauge.message(messages.noEngraveMsg);
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  // Click on Save button in Add Engraving section for PC
  if (
    engraveSaveBtn !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'PC'
  ) {
    await t.evaluate(await t.$(engraveSaveBtn), (ele) => {
      ele.focus();
      ele.click();
    });
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  // Click on Save button in Add Engraving section for Mobile
  if (
    engravePreviewBtnMob !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE'
  ) {
    await t.evaluate(await t.$(engravePreviewBtnMob), (ele) => {
      ele.focus();
      ele.click();
    });
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  if (
    engraveSaveBtnMob !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE'
  ) {
    await t.evaluate(await t.$(engraveSaveBtnMob), (ele) => {
      ele.focus();
      ele.click();
    });
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  // Verification of Saved Engraving Text in Saved Engraving section
  if (savedEngravingSection !== '' && savedEngravingText !== '') {
    if (
      await (
        await t.$(savedEngravingSection)
      ).exists(pollingtime, increaseTimeout)
    ) {
      const SavedEngravingMessage = await (
        await t.$(savedEngravingText)
      ).text();
      if (SavedEngravingMessage === CommonData.engrMsg) {
        assert(matchCondition);
        gauge.message(
          'Saved Engraving message is correct: ' + SavedEngravingMessage
        );
        gauge.screenshot();
      } else {
        assert(!matchCondition);
        gauge.message(
          'Saved Engraving message is not correct: ' + SavedEngravingMessage
        );
      }
    } else {
      gauge.message(messages.stepNotApplicable);
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function collectionpoint() {
  await t.waitFor(timeout);
  if (enterFirstName !== '') {
    await t.write(CommonData.firstName, t.into(await t.$(enterFirstName)));
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  if (enterLastName !== '') {
    await t.write(CommonData.lastName, t.into(await t.$(enterLastName)));
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  if (enterPhoneNo !== '') {
    await t.write(CommonData.phone, t.into(await t.$(enterPhoneNo)));
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  gauge.screenshot();

  if (clickSelectCollection !== '') {
    await t.evaluate(
      await t.$(clickSelectCollection, {
        waitForEvents: ['loadEventFired'],
      }),
      (ele) => ele.click()
    );
    await t.write(CommonData.enterCcPostCode, t.into(await t.$(enterPostCode)));
    await t.evaluate(
      await t.$(clickSearchPostCode, { waitForEvents: ['loadEventFired'] }),
      (ele) => ele.click()
    );
    gauge.screenshot();
    if (clickMapPanel !== '') {
      await t.evaluate(
        await t.$(clickMapPanel, { waitForEvents: ['loadEventFired'] }),
        (ele) => ele.click()
      );
      await t.waitFor(timeout);
    }
    await t.evaluate(
      await t.$(selectAccessPoint, { waitForEvents: ['loadEventFired'] }),
      (ele) => ele.click()
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  if (clickOnShipDetContBtn !== '') {
    await t.evaluate(await t.$(clickOnShipDetContBtn), (ele) => ele.click());
    await t.waitFor(timeout);
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  if (clickOnOrderRevDetContBtn !== '') {
    await t.waitFor(timeout);
    await t.evaluate(await t.$(clickOnOrderRevDetContBtn), (ele) =>
      ele.click()
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function billingdetails() {
  if (enterBillingFirstName !== '') {
    await t.write(
      CommonData.firstName,
      t.into(t.textBox({ id: enterBillingFirstName }))
    );
    await t.write(
      CommonData.lastName,
      t.into(t.textBox({ id: enterBillingLastName }))
    );
    // await t.evaluate(t.link(manualAddressLink), (ele) => ele.click());
    await t.write(
      CommonData.address1,
      t.into(t.textBox({ id: enterBillingAddress1 }))
    );
    await t.write(
      CommonData.address2,
      t.into(t.textBox({ id: enterBillingAddress2 }))
    );
    await t.write(
      CommonData.zipCode,
      t.into(t.textBox({ id: enterBillingZipCode }))
    );
    await t.write(
      CommonData.phone,
      t.into(t.textBox({ id: enterBillingPhoneNo }))
    );
    await t.write(CommonData.city, t.into(t.textBox({ id: enterBillingCity })));
    if (enterBillingAddress4 !== '') {
      await t.write(
        CommonData.address4,
        t.into(t.textBox({ id: enterBillingAddress4 }))
      );
    }
    await t.evaluate(
      await t.$(clickSaveBtn, { waitForEvents: ['loadEventFired'] }),
      (ele) => ele.click()
    );
    await t.waitFor(timeout); // added static timeout to handle lower environments
  }
}

async function clearpaycredentials() {
  // click on clearpay Radiobutton and CTA
  if (clickOnClearPayRadioBtn !== '') {
    await t.scrollDown(parseInt(scrollDownvalueClearPay, scrollValue));
    await t.evaluate(
      await t.$(clickOnClearPayRadioBtn, {
        waitForEvents: ['loadEventFired'],
      }),
      (ele) => ele.click()
    );
    gauge.screenshot();
    await t.waitFor(await t.$(clickOnClearPayCta), increaseTimeout);
    await t.evaluate(await t.$(clickOnClearPayCta), (ele) => ele.click(), {
      waitForNavigation: false,
    });
    await t.waitFor(timeout);
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  // click on not you button in clearpay portal
  if (
    clickOnNotyouBtn !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    try {
      await t.evaluate(await t.$(clickOnNotyouBtn), (ele) => {
        ele.focus();
        ele.click();
      });
      await t.waitFor(timeout);
    } catch (e) {
      gauge.message(messages.clickNotYouMsg);
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  // Enter ClearPay Email Credential
  if (
    enterClearPayEmail !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.waitFor(timeout); // added static timeout to handle lower environments
    await t.focus(await t.$(enterClearPayEmail));
    await t.press(['Control', 'KeyA']);
    await t.press('Delete', { waitForStart: pollingtime });
    await t.write(
      CommonData.clearpayEmail,
      t.into(await t.$(enterClearPayEmail), { delay: pollingtime })
    );
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  // Click On Clearpay Email Continue CTA
  if (
    contClearPayEmail !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    if (await (await t.$(contClearPayEmail)).exists()) {
      await t.evaluate(await t.$(contClearPayEmail), (ele) => ele.click(), {
        waitForNavigation: false,
      });
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  // Enter ClearPay Password Credential
  if (
    enterClearPayPassword !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.waitFor(await t.$(enterClearPayPassword), increaseTimeout);
    await t.waitFor(timeout); // clearpay portal loading takes more time in low env but in prod we are skipping this step.
    await t.write(
      CommonData.clearpayPassword,
      t.into(await t.$(enterClearPayPassword), { delay: pollingtime })
    );
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  // Click On Clearpay Password Continue CTA
  if (
    contClearPayPassword !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    if (await (await t.$(contClearPayPassword)).exists()) {
      await t.evaluate(await t.$(contClearPayPassword), (ele) => ele.click(), {
        waitForNavigation: false,
      });
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  // Click On Clearpay Confirm CTA
  if (
    contClearPayConf !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.waitFor(timeout);
    if (
      await (await t.$(contClearPayConf)).exists(pollingtime, increaseTimeout)
    ) {
      await t.evaluate(await t.$(contClearPayConf), (ele) => ele.click(), {
        waitForNavigation: false,
      });
      //await t.waitFor(timeout); // added static timeout to handle lower environments
      gauge.screenshot();
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function giftcarddetails() {
  if (
    selectGiftCardCheckbox !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.evaluate(await t.$(selectGiftCardCheckbox), (ele) => ele.click());
    await t.write(CommonData.giftCardNo, t.into(await t.$(enterGiftCardNo)), {
      waitForStart: timeout,
      waitForNavigation: false,
      delay: pollingtime,
    });
    await t.press('Tab');
    await t.write(CommonData.pinNo, t.into(await t.$(enterPinNo)), {
      waitForStart: timeout,
      waitForNavigation: false,
      delay: 50,
    });
    await t.press('Tab');
    gauge.screenshot();
    await t.evaluate(await t.$(applyGiftCard), (ele) => ele.click(), {
      waitForNavigation: false,
    });
    if (!(await (await t.$(invalidGiftCardMsg)).exists())) {
      assert(matchCondition);
      gauge.screenshot();
      gauge.message(messages.giftcardsuccessmsg);
    } else if (await (await t.$(invalidGiftCardMsg)).exists()) {
      gauge.message(messages.giftcardfailmsg);
      assert(!matchCondition);
      gauge.screenshot();
    }
    if (await (await t.$(termsAndConGiftCard)).exists()) {
      await t.evaluate(
        await t.$(termsAndConGiftCard, {
          waitForEvents: ['DOMContentLoaded'],
        }),
        (ele) => ele.click()
      );
      await t.evaluate(
        await t.$(placeGiftCardOrder, { waitForEvents: ['DOMContentLoaded'] }),
        (ele) => ele.click()
      );
    }
    gauge.screenshot();
  }
  // added this logic for RCO implemented sites GC validation
  if (
    selectGiftCardCheckboxRco !== '' &&
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await t.waitFor(timeout);
    await t.evaluate(await t.$(selectGiftCardCheckboxRco), (ele) =>
      ele.click()
    );
    await t.write(
      CommonData.giftCardNo,
      t.into(await t.$(enterGiftCardNoRco)),
      {
        waitForStart: timeout,
        waitForNavigation: false,
        delay: pollingtime,
      }
    );
    await t.press('Tab');
    await t.write(CommonData.pinNo, t.into(await t.$(enterPinNoRco)), {
      waitForStart: timeout,
      waitForNavigation: false,
      delay: pollingtime,
    });
    await t.press(['Tab', 'Enter']);
    gauge.screenshot();
    if (!(await (await t.$(invalidGiftCardMsgRco)).exists())) {
      assert(matchCondition);
      gauge.screenshot();
      gauge.message(messages.giftcardsuccessmsg);
    } else if (await (await t.$(invalidGiftCardMsgRco)).exists()) {
      gauge.message(messages.giftcardfailmsg);
      assert(!matchCondition);
      gauge.screenshot();
    }
    if (await (await t.$(placeGiftCardOrderRco)).exists()) {
      await t.evaluate(
        await t.$(placeGiftCardOrderRco, {
          waitForEvents: ['DOMContentLoaded'],
        }),
        (ele) => ele.click()
      );
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
    gauge.screenshot();
  }
}

async function placeorder() {
  if (await (await t.$(orderConfMsgID)).exists(timeout)) {
    // if (orderConfMsgID !== '')
    assert(matchCondition);
    const confirmurl = await t.currentURL();
    const getOrderNumbertxt = await (await t.$(orderConfMsgID)).text();
    getOrderNumber = getOrderNumbertxt.trim();
    if (confirmurl.includes(CommonData.checkoutConfUrl1)) {
      assert(confirmurl.includes(CommonData.checkoutConfUrl1));
    } else if (confirmurl.includes(CommonData.checkoutConfUrl2)) {
      assert(confirmurl.includes(CommonData.checkoutConfUrl2));
    } else {
      gauge.message(messages.orderNoNotDisplayed);
      assert(!matchCondition);
    }
    gauge.message(getOrderNumber);
    console.log(getOrderNumber);
    gauge.message(messages.successMsg);
  } else {
    gauge.message(messages.errorMsg);
    assert(!matchCondition);
  }
  gauge.screenshot();
}

async function gumailId() {
  if (enterGuestUserNewUserID !== '') {
    const guestUserEmailIdUkReg = makeEmail();
    await t.write(
      guestUserEmailIdUkReg,
      t.into(await t.$(enterGuestUserNewUserID))
    );
    gauge.screenshot();
    gauge.message('Guest user Email ID: ' + guestUserEmailIdUkReg);
  }
  if (clickGuestUserNewuserContBtn !== '') {
    await t.evaluate(t.button({ id: clickGuestUserNewuserContBtn }), (ele) =>
      ele.click()
    );
    await t.waitFor(timeout);
  }
}

async function rumailId() {
  if (clickReturnUserRadioButtonMob !== '') {
    await t.evaluate(await t.$(clickReturnUserRadioButtonMob), (ele) =>
      ele.click()
    );
  }

  if (enterReturnUserID !== '') {
    const ReturnUserIdUkReg = ReturnUserID();
    await t.write(ReturnUserIdUkReg, t.into(await t.$(enterReturnUserID)));
    gauge.screenshot();
    gauge.message('Return user Email ID: ' + ReturnUserIdUkReg);
  }

  if (enterReturnUserPassword !== '') {
    await t.write(
      CommonData.ruPassword,
      t.into(await t.$(enterReturnUserPassword))
    );
  }

  if (clickOnReturnUserSigninBtn !== '') {
    await t.evaluate(await t.$(clickOnReturnUserSigninBtn), (ele) =>
      ele.click()
    );
  }
}

// below logic is used for sign in as a return user before products adding into cart
async function enterReturnUserLoginDetails() {
  if (
    clickOnReturnUserLink !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'PC'
  ) {
    await t.evaluate(await t.$(clickOnReturnUserLink), (ele) => ele.click());
  } else {
    gauge.message(messages.stepNotApplicable);
  }

  if (
    clickOnReturnUserLinkMob !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE'
  ) {
    await t.evaluate(await t.$(clickOnReturnUserLinkMob), (ele) => ele.click());
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  // await gen.ElementAction(clickReturnUserLink1);
  if (accReturnUserEmailID !== '') {
    const ReturnUserIdUkReg = ReturnUserID();
    await t.write(ReturnUserIdUkReg, t.into(await t.$(accReturnUserEmailID)));
    gauge.message('Return user Email ID: ' + ReturnUserIdUkReg);
    gauge.screenshot();
  }
  if (accReturnUserPassword !== '') {
    await t.write(
      CommonData.ruPassword,
      t.into(await t.$(accReturnUserPassword))
    );
  }
  if (accReturnUserLoginBtn !== '') {
    await t.evaluate(await t.$(accReturnUserLoginBtn), (ele) => ele.click());
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function clickOnCreateAccountIndexPageUKREG() {
  if (newUserCreateAccountBtn !== '') {
    if (
      !(await (
        await t.$(newUserCreateAccountBtn)
      ).isDisabled(pollingtime, increaseTimeout))
    ) {
      gauge.message(messages.regButtonClick);
    }
    await t.evaluate(await t.$(newUserCreateAccountBtn), (ele) => ele.focus());
    await t.click(await t.$(newUserCreateAccountBtn), {
      waitForNavigation: false,
    });
    if (
      await (
        await t.$(clickOnAccountSignoutBtn)
      ).exists(pollingtime, increaseTimeout)
    ) {
      const confirmurl1 = await t.currentURL();
      if (confirmurl1.includes(CommonData.accountConfirmUrl)) {
        assert(matchCondition);
        gauge.message(messages.accSuccessMsg);
      } else {
        gauge.message(messages.accErrorMsg);
        assert(!matchCondition);
      }
      gauge.screenshot();
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function gotoAccountSigninurlUKREG() {
  if (navigateToAccountSigninUrl !== '') {
    await t.goto(
      siteDefinition.executionContext.url + navigateToAccountSigninUrl,
      {
        waitForEvents: ['DOMContentLoaded'],
      }
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function enterAccountRegistrationDetailsUKREG() {
  let Accountregistration = 0;
  if (accRegistrationFirstName !== '') {
    await t.write(
      CommonData.firstName,
      t.into(t.textBox({ 'data-test-id': accRegistrationFirstName }))
    );
    Accountregistration++;
  }
  if (accRegistrationLastName !== '') {
    await t.write(
      CommonData.lastName,
      t.into(t.textBox({ 'data-test-id': accRegistrationLastName }))
    );
    Accountregistration++;
  }
  if (accRegisterEmailID !== '') {
    const newUserCreateMailId = makeEmail();
    await t.write(
      newUserCreateMailId,
      t.into(t.textBox({ 'data-test-id': accRegisterEmailID }))
    );
    gauge.message('New User Mail ID : ' + newUserCreateMailId);
    Accountregistration++;
  }
  if (accRegisterPassword !== '') {
    await t.write(
      CommonData.nuPassword,
      t.into(t.textBox({ 'data-test-id': accRegisterPassword }))
    );
    Accountregistration++;
  }
  if (accRegisterationTerms !== '') {
    await t.evaluate(t.checkBox({ id: accRegisterationTerms }), (ele) =>
      ele.click()
    );
    Accountregistration++;
  }
  if (accRegisterBtn !== '') {
    await t.evaluate(await t.$(accRegisterBtn), (ele) => ele.click());
    Accountregistration++;
  }
  if (Accountregistration === 0) {
    gauge.message(messages.stepNotApplicable);
  }
  gauge.screenshot();
}

async function pureprivilgememberID() {
  if (memberID !== '') {
    if (await (await t.$(memberID)).exists()) {
      assert(matchCondition);
      const MemberNumber = await (await t.$(memberID)).text();
      gauge.message(messages.ppSuccessMsg);
      gauge.message(MemberNumber);
      gauge.screenshot();
    } else {
      gauge.message(messages.ppErrorMsg);
      assert(!matchCondition);
    }
    gauge.screenshot();
  }
}

// Loyalty checkout functions

async function enterLOYRegistrationDetailsUkReg() {
  let Accountregistration = 0;
  if (accRegistrationFirstName !== '') {
    await t.write(
      CommonData.FIRSTNAME,
      t.into(t.textBox({ 'data-test-id': accRegistrationFirstName }))
    );
    Accountregistration++;
  }
  if (accRegistrationLastName !== '') {
    await t.write(
      CommonData.LASTNAME,
      t.into(t.textBox({ 'data-test-id': accRegistrationLastName }))
    );
    Accountregistration++;
  }
  if (accRegisterEmailID !== '') {
    const newUserCreateMailId = makeEmail();
    await t.write(
      newUserCreateMailId,
      t.into(t.textBox({ 'data-test-id': accRegisterEmailID }))
    );
    gauge.message('New User Mail ID : ' + newUserCreateMailId);
    Accountregistration++;
  }
  if (accRegisterPassword !== '') {
    await t.write(
      CommonData.nuPassword,
      t.into(t.textBox({ 'data-test-id': accRegisterPassword }))
    );
    Accountregistration++;
  }
  if (accRegisterationTerms !== '') {
    await t.evaluate(t.checkBox({ id: accRegisterationTerms }), (ele) =>
      ele.click()
    );
    Accountregistration++;
  }
  if (loyCheckbox !== '') {
    await t.evaluate(await t.$(loyCheckbox), (ele) => ele.click());
    Accountregistration++;
  }
  if (accRegisterBtn !== '') {
    await t.evaluate(await t.$(accRegisterBtn), (ele) => ele.click());
    Accountregistration++;
  }
  if (Accountregistration === 0) {
    gauge.message(messages.stepNotApplicable);
  }
  gauge.screenshot();
}

async function loyaltytier2usercreds() {
  if (enterReturnUserID !== '') {
    await t.write(
      CommonData.loyTier2RuMailID,
      t.into(await t.$(enterReturnUserID))
    );
    gauge.message(
      'Loyalty tier2 user Email ID: ' + CommonData.loyTier3RuMailID
    );
    await t.write(
      CommonData.loyTier2RuPassword,
      t.into(await t.$(enterReturnUserPassword))
    );
    await t.evaluate(await t.$(clickOnReturnUserSigninBtn), (ele) =>
      ele.click()
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function loyaltytier3usercreds() {
  if (enterReturnUserID !== '') {
    await t.write(
      CommonData.loyTier3RuMailID,
      t.into(await t.$(enterReturnUserID))
    );
    gauge.message(
      'Loyalty tier3 user Email ID: ' + CommonData.loyTier3RuMailID
    );
    await t.write(
      CommonData.loyTier3RuPassword,
      t.into(await t.$(enterReturnUserPassword))
    );
    await t.evaluate(await t.$(clickOnReturnUserSigninBtn), (ele) =>
      ele.click()
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

// Below logic used for Facebook login
async function clickOnFbCheckbox() {
  if (fbCheckbox1 !== '') {
    await t.evaluate(
      await t.$(fbCheckbox1, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.waitFor(increaseTimeout);
    await t.focus(await t.$(fbCheckbox1));
    await t.press(['Shift', 'Tab', 'Enter']);
  } else if (fbCheckbox2 !== '') {
    await t.evaluate(
      await t.$(fbCheckbox2, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.waitFor(increaseTimeout);
    await t.focus(await t.$(fbCheckbox2));
    await t.press(['Shift', 'Tab', 'Shift', 'Tab', 'Enter']);
  } else if (fbCheckbox3 !== '') {
    await t.evaluate(
      await t.$(fbCheckbox3, { waitForEvents: ['DOMContentLoaded'] }),
      (ele) => ele.click()
    );
    await t.waitFor(timeout);
    await t.evaluate(await t.$(fbCta), (ele) => ele.click());
  }
  gauge.screenshot();
}

async function fbConnectedAccount() {
  if (fbConAccount !== '') {
    await t.waitFor(timeout);
    if (await (await t.$(fbConAccount)).exists()) {
      assert(matchCondition);
      const connectedAccount = await (await t.$(fbConAccount)).text();
      console.log(connectedAccount);
      gauge.message(connectedAccount);
      gauge.screenshot();
    } else {
      assert(!matchCondition);
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  gauge.screenshot();
}

async function proUserCreds() {
  if (enterReturnUserID !== '') {
    await t.write(
      CommonData.proUserMailID,
      t.into(await t.$(enterReturnUserID))
    );
    gauge.message('PRO user Email ID: ' + CommonData.proUserMailID);
    await t.write(
      CommonData.proUserPassword,
      t.into(await t.$(enterReturnUserPassword))
    );
    await t.evaluate(await t.$(clickOnReturnUserSigninBtn), (ele) =>
      ele.click()
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function captureProUserID() {
  if (proUserID !== '') {
    await t.scrollDown(await t.$(proUserID));
    if (await (await t.$(proUserID)).exists()) {
      assert(matchCondition);
      const proMemberNumber = await (await t.$(proUserID)).text();
      const proDiscount = await (await t.$(proDisc)).text();
      const expiryDate = await (await t.$(proExpDate)).text();
      gauge.message(messages.proSuccessMsg);
      gauge.message(
        'Member Card Number : ' +
          proMemberNumber +
          '\nDiscount : ' +
          proDiscount +
          '\nExpiration Date : ' +
          expiryDate
      );
      gauge.screenshot();
    } else {
      gauge.message(messages.proErrorMsg);
      assert(!matchCondition);
    }
    gauge.screenshot();
  }
}

async function openTestOrderUrlUkreg() {
  if (
    testOrderUrl !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'PC'
  ) {
    await t.setCookie('testtrans', '1', {
      url: Helper.getBaseUrl(siteDefinition) + testOrderUrl,
    });
  } else if (
    testOrderUrl !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE'
  ) {
    await t.setCookie('testtrans', '1', {
      url: Helper.getBaseUrl(siteDefinition) + testOrderUrl,
    });
  }
}

async function openSharedAdminTool() {
  if (
    sharedAdminToolUrl !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'PC'
  ) {
    await t.goto(
      siteDefinition.executionContext.adminUrl + sharedAdminToolUrl,
      {
        waitForEvents: ['DOMContentLoaded'],
      }
    );
  } else if (
    sharedAdminToolUrl !== '' &&
    siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE'
  ) {
    await t.goto(
      siteDefinition.executionContext.adminUrl + sharedAdminToolUrl,
      {
        waitForEvents: ['DOMContentLoaded'],
      }
    );
  }
}

async function loginSharedAdminTool() {
  if (poaUserEmailId !== '' && poaUserPwd !== '' && poaLoginCta !== '') {
    await gen.ElementAction(poalogindetails);
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function enterCustEmailAdd() {
  if (bcmCustEmailId !== '') {
    const returnUserIdUKREG = ReturnUserID();
    await t.write(returnUserIdUKREG, t.into(await t.$(bcmCustEmailId)));
    gauge.screenshot();
    gauge.message(
      'Become Customer (Return user) Email ID: ' + returnUserIdUKREG
    );
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function navToOrdHstPage() {
  await t.goto(siteDefinition.executionContext.url + ordrHstPageUrl, {
    waitForEvents: ['DOMContentLoaded'],
  });
}

async function srchandClkOrdNumOrOrdDetlnk() {
  if (totalOrderNumLinklen !== '') {
    const getorderNumLinkElements = await (
      await t.$(totalOrderNumLinklen)
    ).elements();
    const getorderNumLinkLen = getorderNumLinkElements.length;
    for (let i = 1; i <= getorderNumLinkLen; i++) {
      const orderNumLinktxt = await (
        await t.$(orderNumLink + '[' + i + ']')
      ).text();
      const orderNumLinktxtlen = orderNumLinktxt.length;
      const getOrderNumberlen = getOrderNumber.length;
      const getorderNumLinktxt = getOrderNumber.slice(
        getOrderNumberlen - orderNumLinktxtlen
      );
      if (getorderNumLinktxt === orderNumLinktxt) {
        gauge.screenshot();
        await t.evaluate(await t.$(orderDetailsLink + '[' + i + ']'), (ele) =>
          ele.click()
        );
        break;
      } else {
        const regExpOrdNumPattern1 = CommonData.regExpOrdNumPat1;
        const regExpOrdNumPattern2 = CommonData.regExpOrdNumPat2;
        const regExpOrdNumPatternObj = new RegExp(
          regExpOrdNumPattern1,
          regExpOrdNumPattern2
        );
        const getorderNumLinktxt1 = getOrderNumber.replace(
          regExpOrdNumPatternObj,
          ''
        );
        const orderNumLinktxt1 = orderNumLinktxt.replace(
          regExpOrdNumPatternObj,
          ''
        );
        if (getorderNumLinktxt1 === orderNumLinktxt1) {
          gauge.screenshot();
          if (await (await t.$(orderExpand + '[' + i + ']')).exists()) {
            await t.evaluate(await t.$(orderExpand + '[' + i + ']'), (ele) =>
              ele.click()
            );
            await t.evaluate(
              await t.$(orderDetailsLink + '[' + i + ']'),
              (ele) => ele.click()
            );
          } else {
            await t.evaluate(
              await t.$(
                '//*[@data-orderid = ' +
                  orderNumLinktxt1 +
                  ' and ' +
                  orderDetailsLink +
                  ']' +
                  '|' +
                  orderDetailsLink +
                  '[' +
                  i +
                  ']'
              ),
              (ele) => ele.click()
            );
          }
          break;
        }
      }
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

async function entCreditCardDetails() {
  if (
    cardNumtxtfld !== '' &&
    expiryDatetxtfld !== '' &&
    secCodetxtfld !== '' &&
    cardHoldertxtfld !== ''
  ) {
    await t.write(
      CommonData.pblCreditCardNumber,
      t.into(await t.$(cardNumtxtfld))
    );
    await t.write(CommonData.pblExpDate, t.into(await t.$(expiryDatetxtfld)));
    await t.write(CommonData.pblSecCode, t.into(await t.$(secCodetxtfld)));
    await t.write(
      CommonData.pblCardHolderName,
      t.into(await t.$(cardHoldertxtfld))
    );
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function entBillingDetails() {
  if (
    countrydrpdwn !== '' &&
    houseNumtxtfld !== '' &&
    streetxtfld !== '' &&
    citytxtfld !== '' &&
    postCodetxtfld !== '' &&
    paybtn !== ''
  ) {
    await t.write(CommonData.country, t.into(await t.$(countrydrpdwn)));
    await t.evaluate(await t.$(selCountry), (ele) => ele.click());
    await t.write(CommonData.address1, t.into(await t.$(houseNumtxtfld)));
    await t.write(CommonData.address2, t.into(await t.$(streetxtfld)));
    await t.write(CommonData.city, t.into(await t.$(citytxtfld)));
    await t.write(CommonData.zipCode, t.into(await t.$(postCodetxtfld)));
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function pblPaymentPaidPage() {
  if (paymentPaidPageMsg !== '') {
    if (await (await t.$(paymentPaidPageMsg)).exists()) {
      const paymentPaidPagetxt = await (await t.$(paymentPaidPageMsg)).text();
      const paymentPaidCommonDatatxt = CommonData.paymentPaidText;
      if (paymentPaidPagetxt === paymentPaidCommonDatatxt) {
        assert(true);
        gauge.message(paymentPaidPagetxt);
        gauge.screenshot();
      }
    } else {
      gauge.message(messages.paymentFailure);
      assert(false);
    }
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

async function addVirtualsetProduct() {
  for (let i = 0; i < vsSkuIds.length; i++) {
    await t.goto(
      siteDefinition.executionContext.adminUrl + prodcatUrl + vsSkuIds[i],
      {
        waitForEvents: ['DOMContentLoaded'],
      }
    );
    gauge.screenshot();
    if (await (await t.$(isShoppable)).exists()) {
      const isShoppableValue = await (await t.$(isShoppable)).text();
      if (isShoppableValue === '1') {
        gauge.message(
          'The Product with SKU ID - ' +
            vsSkuIds[i] +
            ' is available and proceeding to add to Cart'
        );
        if (
          siteDefinition.executionContext.environment.toUpperCase() ===
            'PROD' ||
          siteDefinition.executionContext.environment.toUpperCase() ===
            'PREPROD'
        ) {
          await t.evaluate(await t.$(addToCart), (ele) => ele.click(), {
            waitForNavigation: false,
          });
          for (i = 0; i <= 2; i++) {
            if (
              !(await (
                await t.$(checkoutBtnID)
              ).exists(pollingtime, increaseTimeout))
            ) {
              gauge.message(messages.viewcartLoadMsg);
              await t.reload();
              await t.waitFor(await t.$(checkoutBtnID), increaseTimeout);
            } else {
              break;
            }
          }
        } else {
          const elements = await (await t.$(addToCart)).elements();
          const attributePromises = elements.map((e) => {
            return t.evaluate(e, (elem) => {
              return elem.getAttribute('href');
            });
          });
          viewCartUrl = await Promise.all(attributePromises);
          await t.goto(siteDefinition.executionContext.url + viewCartUrl, {
            waitForEvents: ['DOMContentLoaded'],
          });
          gauge.screenshot();
        }
        break;
      } else {
        gauge.message(
          'The Product with SKU ID - ' +
            vsSkuIds[i] +
            ' is NOT available for adding it to Cart '
        );
        notAvailableProductsCount++;
      }
    } else {
      gauge.message(vsSkuIds[i] + ' is not a valid SKU ID');
    }
  }
  if (notAvailableProductsCount === vsSkuIds.length) {
    assert(
      !matchCondition,
      'None of the products are available for adding it to Cart'
    );
  }
}

async function addDonationFromSharedTool() {
  if (CommonData.donationSkuId !== '') {
    await t.goto(
      siteDefinition.executionContext.adminUrl +
        prodcatUrlDonation +
        CommonData.donationSkuId,
      { waitForEvents: ['DOMContentLoaded'] }
    );
    if (await (await t.$(isshoppableDonation)).exists()) {
      const isShoppableValue = await (await t.$(isshoppableDonation)).text();
      if (isShoppableValue === '1') {
        gauge.message(
          'The Product with SKU ID - ' +
            CommonData.donationSkuId +
            ' is available and proceeding to add to Cart'
        );
        const elements = await (
          await t.$("//a[contains(text(),'Add to Cart')]")
        ).elements();
        const attributePromises = elements.map((e) => {
          return t.evaluate(e, (elem) => {
            return elem.getAttribute('href');
          });
        });
        viewCartUrl = await Promise.all(attributePromises);
        await t.goto(siteDefinition.executionContext.url + viewCartUrl, {
          waitForEvents: ['DOMContentLoaded'],
        });
        gauge.screenshot();
      } else {
        gauge.message(
          'The Product with SKU ID - ' +
            CommonData.donationSkuId +
            ' is NOT available for adding it to Cart '
        );
      }
    } else {
      gauge.message(CommonData.donationSkuId + ' is not a valid SKU ID');
    }
  } else {
    gauge.message('This step is not applicable for this Brand/Locale');
  }
}

async function clickOnDonationCtaOnViewcart(donationamount) {
  if (clickDonationAddCta !== '') {
    await t.evaluate(await t.$(clickDonationAddCta), (ele) => ele.click());
  }
  const donationAmount = parseInt(donationamount, 10);
  if (
    donationValueFirst !== '' ||
    donationValueSecond !== '' ||
    donationValueThird !== ''
  ) {
    if (donationAmount === parseInt(CommonData.donationValueOne, 10)) {
      await t.evaluate(
        await t.$(donationValueFirst, { waitForEvents: ['DOMContentLoaded'] }),
        (ele) => ele.click()
      );
      gauge.screenshot();
    } else if (donationAmount === parseInt(CommonData.donationValueFive, 10)) {
      await t.evaluate(
        await t.$(donationValueSecond, { waitForEvents: ['DOMContentLoaded'] }),
        (ele) => ele.click()
      );
      gauge.screenshot();
    } else if (donationAmount === parseInt(CommonData.donationValueTen, 10)) {
      await t.evaluate(
        await t.$(donationValueThird, { waitForEvents: ['DOMContentLoaded'] }),
        (ele) => ele.click()
      );
      gauge.screenshot();
    }
    if (confirmDonation !== '') {
      await t.evaluate(
        await t.$(confirmDonation, { waitForEvents: ['DOMContentLoaded'] }),
        (ele) => ele.click()
      );
    }
  } else {
    gauge.message('This brand donot have Donations');
  }
}

async function clearpayCtaAvailability() {
  if (clickOnClearPayRadioBtn !== '') {
    await t.scrollDown(scrollDownValue);
    if (await (await t.$(clickOnClearPayRadioBtn)).exists()) {
      gauge.message('Clearpay CTA available in payment review page');
      assert(false);
    } else {
      gauge.message(
        'Clearpay CTA not available in payment review page while donation added into cart'
      );
      assert(true);
    }
  } else {
    gauge.message('This step is not applicable for this Brand/Locale');
  }
}

async function navigateToSppPage() {
  await t.goto(siteDefinition.executionContext.url + sppPageUrl, {
    waitForEvents: ['DOMContentLoaded'],
  });
}

async function socialShareOptions(genSocialShare, socialSharePage, mediaTitle) {
  if (genSocialShare !== '') {
    await gen.ElementAction(cookieReject);
    await t.evaluate(await t.$(genSocialShare), (ele) => ele.scrollIntoView());
    await t.evaluate(await t.$(genSocialShare), (ele) => ele.click());
    await t.waitFor(5000); // Social share icon loading taking time
    const socialPage = await (await t.$(socialSharePage)).text();
    if (socialPage === mediaTitle) {
      assert(matchCondition);
      gauge.message(`Navigated to ${mediaTitle} page as expected`);
      gauge.screenshot();
    } else {
      assert(!matchCondition);
      gauge.message(
        `Not Navigated to ${mediaTitle} page, Error Encountered !!!`
      );
    }
    await t.closeTab();
  }
}

async function navigateToEmbossingPage() {
  await t.goto(siteDefinition.executionContext.url + embossingPageUrl, {
    waitForEvents: ['DOMContentLoaded'],
  });
}

// Check the Gift Wrap Check Box
async function checkGiftWrap() {
  if (giftWrapCheckBox !== '' && giftWrapCheckBoxAlreadyChecked != '') {
    await t.waitFor(timeout);
    if (await (await t.$(giftWrapCheckBox)).exists()) {
      await t.evaluate(await t.$(giftWrapCheckBox), (ele) => ele.click());
      gauge.message(messages.giftWrapChkBx + ' is available and checked');
    } else if (await (await t.$(giftWrapCheckBoxAlreadyChecked)).exists()) {
      gauge.message(
        messages.giftWrapChkBx + ' is available and already checked'
      );
    } else {
      gauge.message(messages.giftWrapChkBx + ' is not available');
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Uncheck the Gift Wrap Check Box
async function uncheckGiftWrap() {
  if (giftWrapCheckBoxAlreadyChecked != '') {
    if (await (await t.$(giftWrapCheckBoxAlreadyChecked)).exists()) {
      await t.evaluate(await t.$(giftWrapCheckBoxAlreadyChecked), (ele) =>
        ele.click()
      );
      await t.waitFor(timeout);
      gauge.message(messages.giftWrapChkBx + ' is unchecked');
    } else {
      gauge.message(messages.giftWrapChkBx + ' is already unchecked');
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Add the Valid/Invalid Gift Message and assign the correct Gift Wrap value price to the Variable
async function addGiftMessage(giftMessage) {
  if (addGiftMessageCTA != '' && giftMessageBox != '') {
    if (await (await t.$(addGiftMessageCTA)).exists(pollingtime, timeout)) {
      gauge.message(messages.giftMsg + ' ADD CTA is available');
      await t.evaluate(await t.$(addGiftMessageCTA), (ele) => ele.click());
    } else if (await (await t.$(cancelGiftMessageCTA)).exists()) {
      gauge.message(messages.giftMsg + ' Cancel CTA is available');
    } else {
      gauge.message('No ' + messages.giftMsg + ' CTA is available');
    }
    if (await (await t.$(giftMessageBox)).exists()) {
      gauge.message(messages.giftMsg + ' Box is available');
      await t.evaluate(await t.$(giftMessageBox), (ele) => ele.click());
      await t.clear(await t.$(giftMessageBox));
      if (giftMessage === 'validGiftMessage') {
        await t.write(
          CommonData.validGiftMessage,
          t.into(await t.$(giftMessageBox))
        );
        gauge.message(
          'Valid ' +
            messages.giftMsg +
            ':' +
            CommonData.validGiftMessage +
            ' is entered'
        );
      }
      if (giftMessage === 'invalidGiftMessage') {
        await t.write(
          CommonData.invalidGiftMessage,
          t.into(await t.$(giftMessageBox))
        );
        gauge.message(
          'Invalid ' +
            messages.giftMsg +
            ':' +
            CommonData.invalidGiftMessage +
            ' is entered'
        );
      }
    } else {
      gauge.message('No Gift Message Box is available');
    }
    // For assigning the correct Gift Wrap value price to the variable
    const getGiftWrapValElements = await (
      await t.$(giftWrapValDelPageGitWrapSec)
    ).elements();
    const getGiftWrapValkLen = getGiftWrapValElements.length;
    if (getGiftWrapValkLen == '1') {
      giftWrapPriceVal = await (await t.$(giftWrapValDelPageGitWrapSec)).text();
    } else {
      giftWrapPriceVal = await (
        await t.$(giftWrapValDelPageGitWrapSec + '[' + 2 + ']')
      ).text();
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Cancel the Gift Message
async function cancelGiftMessage() {
  if (cancelGiftMessageCTA != '') {
    if (await (await t.$(cancelGiftMessageCTA)).exists()) {
      gauge.message(messages.giftMsg + ' Cancel CTA is available');
      await t.evaluate(await t.$(cancelGiftMessageCTA), (ele) => ele.click());
      gauge.message(
        messages.giftMsg + ' Cancel CTA is clicked and its section disappeared'
      );
    } else {
      gauge.message(messages.giftMsg + ' Cancel CTA is not available');
    }
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Verify the Warning message for Invalid Message
async function invalidMessageVerification() {
  if (invalidMessage !== '') {
    await t.waitFor(timeout);
    if (await (await t.$(invalidMessage)).exists()) {
      assert(matchCondition);
      gauge.screenshot();
      gauge.message(messages.invalidsuccessmsg);
    } else {
      gauge.message(messages.invalidfailmsg);
      assert(!matchCondition);
    }
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Edit the Gift Wrap Options
async function editGiftWrapOptions() {
  if (
    giftWrapOptionsSec !== '' &&
    giftWrapOptionsMessage !== '' &&
    giftWrapOptionsEditBtn !== ''
  ) {
    await t.waitFor(timeout);
    if (await (await t.$(giftWrapOptionsSec)).exists()) {
      gauge.message(messages.giftWrap + ' Options Section is available');
      if (await (await t.$(giftWrapOptionsMessage)).exists()) {
        gauge.message(messages.giftWrap + ' Options Message is available');
      }
      if (await (await t.$(giftWrapOptionsEditBtn)).exists()) {
        gauge.message(messages.giftWrap + ' Options Edit button is available');
        gauge.screenshot();
        await t.evaluate(await t.$(giftWrapOptionsEditBtn), (ele) =>
          ele.click()
        );
        gauge.message(messages.giftWrap + ' Options Edit button is clicked');
        await t.waitFor(timeout);
        if (await (await t.$(giftMessageBox)).exists()) {
          gauge.message(messages.giftMsg + ' Box is displayed');
        }
      }
    } else {
      gauge.message(messages.giftWrap + ' Options Section is not available');
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Edit the Gift Message
async function editGiftMessage(giftMessage) {
  if (addGiftMessageCTA !== '' && giftMessageBox != '') {
    await t.evaluate(await t.$(giftMessageBox), (ele) => ele.click());
    await t.clear(await t.$(giftMessageBox));
    if (giftMessage === 'validGiftMessage') {
      await t.write(
        CommonData.validGiftMessage,
        t.into(await t.$(giftMessageBox))
      );
      gauge.message(
        'Valid ' +
          messages.giftmsg +
          ':' +
          CommonData.validGiftMessage +
          ' is entered'
      );
    }
    if (giftMessage === 'invalidGiftMessage') {
      await t.write(
        CommonData.invalidGiftMessage,
        t.into(await t.$(giftMessageBox))
      );
      gauge.message(
        'Invalid ' +
          messages.giftmsg +
          ':' +
          CommonData.invalidGiftMessage +
          ' is entered'
      );
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Verify the Gift Wrap Text and Gift Wrap price
async function giftWrapTextdAndPrice(giftWrapText, giftWrapPrice) {
  if (giftWrapText !== '' && giftWrapPrice !== '') {
    const giftWrapTextField = await await t.$(giftWrapText);
    const giftWrapTextFieldTxt = await giftWrapTextField.text();
    if (giftWrapTextField.exists(pollingtime, increaseTimeout)) {
      gauge.message(
        messages.giftWrap + ' text field is available in ' + messages.ordSummSec
      );
      if (
        giftWrapTextFieldTxt.toUpperCase().includes(CommonData.giftWrapFieldTxt)
      ) {
        gauge.message(
          messages.ordSummSec +
            ' is displaying appropriate Gift Wrap text: ' +
            giftWrapTextFieldTxt
        );
      } else {
        gauge.message(
          messages.ordSummSec +
            ' is not displaying appropriate Gift Wrap text: ' +
            giftWrapTextFieldTxt
        );
      }
    } else {
      gauge.message(
        messages.giftWrap +
          ' text field is not available in ' +
          messages.ordSummSec
      );
    }
    const giftWrapPriceField = await await t.$(giftWrapPrice);
    const giftWrapPriceFieldTxt = await giftWrapPriceField.text();
    if (giftWrapPriceField.exists(pollingtime, increaseTimeout)) {
      gauge.message(
        messages.giftWrap +
          ' Price field is available in ' +
          messages.ordSummSec
      );
      if (
        giftWrapPriceFieldTxt.toUpperCase() ===
        (await giftWrapPriceVal.toUpperCase())
      ) {
        gauge.message(
          messages.ordSummSec +
            ' is displaying appropriate Gift price: ' +
            giftWrapPriceFieldTxt
        );
      } else {
        gauge.message(
          messages.ordSummSec +
            ' is not displaying appropriate Gift price: ' +
            giftWrapPriceFieldTxt
        );
      }
    } else {
      gauge.message(
        messages.giftWrap +
          ' Price field is not available in ' +
          messages.ordSummSec
      );
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

// Verify and Place the Order with Credit Card
async function placeOrderWithCreditCard() {
  if (clickCreditCardCTAId !== '') {
    await gen.ClickAction(clickCreditCardCTAId);
    gauge.message('Credit Card CTA is clicked');
    await t.waitFor(timeout);
    if (
      await (await t.$(orderConfMsgID)).exists(pollingtime, increaseTimeout)
    ) {
      assert(matchCondition);
      const confirmurl = await t.currentURL();
      const getOrderNumbertxt = await (await t.$(orderConfMsgID)).text();
      getOrderNumber = getOrderNumbertxt.trim();
      if (confirmurl.includes(CommonData.checkoutConfUrl1)) {
        assert(confirmurl.includes(CommonData.checkoutConfUrl1));
      } else if (confirmurl.includes(CommonData.checkoutConfUrl2)) {
        assert(confirmurl.includes(CommonData.checkoutConfUrl2));
      } else {
        gauge.message(messages.orderNoNotDisplayed);
        assert(!matchCondition);
      }
      gauge.message(getOrderNumber);
      console.log(getOrderNumber);
      gauge.message(messages.successMsg);
    } else {
      gauge.message(messages.errorMsg);
      assert(!matchCondition);
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.functionNotApplicable);
  }
}

/** OPTIMIZED STEPS */

// No input data table in the spec file
step('UKPAYMENT Initialize Helix', async function () {
  // Initialize the selectors from DB
  await initFrameworkSettings();
});

step(
  'UKPAYMENT Verify that the user able to add products into cart',
  async function () {
    await addtocart();
  }
);

step(
  'UKPAYMENT Verify that the user is able to select click and collect delivery type',
  async function () {
    await gen.ElementAction(cookieReject);
    await gen.getTransId(transID);
    await gen.ElementAction(clickcollect);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
    await gen.ElementAction(cookieReject);
  }
);

step(
  'UKPAYMENT Verify that the user able to signin as a guest user',
  async function () {
    await gen.ElementAction(cookieReject);
    await randompopupreg();
    await gumailId();
  }
);

step(
  'UKPAYMENT Verify that the user able to signin as a return user',
  async function () {
    await gen.ElementAction(cookieReject);
    await rumailId();
    await gen.ElementAction(checkoutbtn);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the user is able to login using their account',
  async function () {
    await gotoAccountSigninurlUKREG();
    await enterReturnUserLoginDetails();
  }
);

step(
  'UKPAYMENT Verify that the user able to select collection point and entering billing details',
  async function () {
    await collectionpoint();
    await billingdetails();
  }
);

step(
  'UKPAYMENT Verify that the user is able to select delivery type <DeliveryType> from dropdown',
  async function (DeliveryType) {
    await gen.ElementAction(cookieReject);
    await gen.getTransId(transID);
    await deliverytype(DeliveryType);
    await gen.ElementAction(checkoutbtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the user is able to select the clearpay payment method successfully',
  async function () {
    await clearpaycredentials();
  }
);

step(
  'UKPAYMENT Verify that the user able to place order with paypal',
  async function () {
    await placeorder();
  }
);

step('UKPAYMENT Verify that the user able to place order', async function () {
  t.waitFor(5000);
  if (
    !(
      siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
      siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
    )
  ) {
    await placeorder();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
});

step(
  'UKPAYMENT Verify that the user able to join as pure privilege memeber',
  async function () {
    await gen.ElementAction(clickonJoinNow);
    await t.waitFor(timeout);
    await reloadviewcart();
    await gen.ElementAction(checkoutbtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the pure privilege user able to enter their address details',
  async function () {
    await gen.ElementAction(ppAddressDetails);
  }
);

step(
  'UKPAYMENT Verify user able to add engrave products to cart',
  async function () {
    await addengraveproduct();
    await gen.ElementAction(cookieReject);
    await addengravetext();
    await gen.getTransId(transID);
    await gen.ElementAction(checkoutbtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify user able to add engrave products and normal products to cart',
  async function () {
    await addengraveproduct();
    await gen.ElementAction(cookieReject);
    await addengravetext();
    await addtocart();
    await gen.getTransId(transID);
    await gen.ElementAction(checkoutbtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the user is able to select express paypal payment',
  async function () {
    await reloadviewcart();
    await gen.getTransId(transID);
    await gen.ElementAction(cookieReject);
    if (siteDefinition.executionContext.platform.toUpperCase() === 'PC') {
      await clickexpaypalCTA();
    } else {
      await clickexpaypalMOBCTA();
    }
    if (
      (await (await t.$(enterExPaypalEmail)).exists()) &&
      !(
        siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
        siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
      )
    ) {
      await paypalcredentials();

      await gen.ElementAction(handleSamplesPage);
      await revdetailscontinuebtn();
      if (siteDefinition.executionContext.platform.toUpperCase() === 'PC') {
        await expaypalconfbtnpc();
      } else {
        await expaypalconfbtnmob();
      }
    }
  }
);

step(
  'UKPAYMENT Verify that the user is able to enter gift card details',
  async function () {
    await giftcarddetails();
  }
);

step(
  'UKPAYMENT Verify that the user is able to select the paypal payment method successfully',
  async function () {
    await clickpaypalRBandCTA();
    await paypalcredentials();
  }
);

step(
  'UKPAYMENT Verify that the new user is able to create account in order confirmation page',
  async function () {
    if (
      !(
        siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
        siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
      )
    ) {
      await gen.ElementAction(createAccount);
      await clickOnCreateAccountIndexPageUKREG();
    } else {
      gauge.message(messages.stepNotApplicable);
    }
  }
);

step(
  'UKPAYMENT Verify that the user is able to select express paypal payment from view cart',
  async function () {
    await reloadviewcart();
    await gen.getTransId(transID);
    await gen.ElementAction(cookieReject);
    gauge.screenshot();
    await clickexpaypalMOBCTA();
    if (
      (await (await t.$(enterExPaypalEmail)).exists()) &&
      !(
        siteDefinition.executionContext.environment.toUpperCase() === 'PROD' ||
        siteDefinition.executionContext.environment.toUpperCase() === 'PREPROD'
      )
    ) {
      await paypalcredentials();
    }
    await gen.ElementAction(handleSamplesPage);
    await revdetailscontinuebtn();
    await expaypalconfbtnmob();
  }
);

step(
  'UKPAYMENT Verify that the user is able to create account',
  async function () {
    await gotoAccountSigninurlUKREG();
    await gen.ElementAction(cookieReject);
    if (siteDefinition.executionContext.platform.toUpperCase() === 'PC') {
      await gen.ElementAction(clickAccountRegisterNowLink);
    } else {
      await gen.ElementAction(clickAccountRegisterNowLinkMOB);
    }
    await enterAccountRegistrationDetailsUKREG();
  }
);

step(
  'UKPAYMENT Verify that the user able to get the memberID successfully',
  async function () {
    await gotoAccountSigninurlUKREG();
    await pureprivilgememberID();
  }
);

step('UKPAYMENT Mobile Device Emulation', async function () {
  await t.emulateDevice('iPhone X');
  gauge.message('Emulation device: iPhone X');
});

step(
  'UKPAYMENT Verify that the loyalty user is able to create account',
  async function () {
    await gotoAccountSigninurlUKREG();
    await gen.ElementAction(cookieReject);
    if (siteDefinition.executionContext.platform.toUpperCase() === 'PC') {
      await gen.ElementAction(clickAccountRegisterNowLink);
    } else {
      await gen.ElementAction(clickAccountRegisterNowLinkMOB);
    }
    await enterLOYRegistrationDetailsUkReg();
  }
);

step(
  'UKPAYMENT Verify that the user is able to see their loyalty points in account page',
  async function () {
    await gotoAccountSigninurlUKREG();
  }
);

step(
  'UKPAYMENT Verify that the loyalty <tier> user able to signin as a return user',
  async function (tier) {
    await gen.ElementAction(cookieReject);
    if (siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE') {
      await gen.ElementAction(clickReturnUserRadioButton1);
    } else {
      await gen.ElementAction(clickReturnUserLink1);
    }
    if (tier === 'tier2') {
      await loyaltytier2usercreds();
    } else {
      await loyaltytier3usercreds();
    }
    await gen.ElementAction(checkoutbtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the user is able signin with their Facebook account',
  async function () {
    await gotoAccountSigninurlUKREG();
    await t.waitFor(increaseTimeout);
    await gen.ElementAction(cookieReject);
    await clickOnFbCheckbox();
    await gen.ElementAction(fbCredentials);
  }
);

step(
  'UKPAYMENT Verify that the user is connected with their Facebook account',
  async function () {
    await fbConnectedAccount();
  }
);

step(
  'UKPAYMENT Verify that the FB user able to continue from cart page',
  async function () {
    await gen.ElementAction(checkoutbtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the user is able to proceed to PRO User Sign in successfully',
  async function () {
    await gen.ElementAction(cookieReject);
    if (siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE') {
      await gen.ElementAction(clickReturnUserRadioButton1);
    } else {
      await gen.ElementAction(clickReturnUserLink1);
    }
    await proUserCreds();
    await gen.ElementAction(checkoutbtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the PRO user is able to see their membership status',
  async function () {
    await gotoAccountSigninurlUKREG();
    await gen.ElementAction(clickProDetails);
    await captureProUserID();
  }
);

step(
  'UKPAYMENT Verify that the user able to select aveda salon service',
  async function () {
    await gen.ElementAction(clickOnSalonService);
  }
);

step('UKPAYMENT Configure Pre-Requisites for POA', async function () {
  if (siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE') {
    await t.emulateDevice(emulationDevice);
    gauge.message(emulationDevice);
  }
  await Helper.setTestOrderCookie(siteDefinition);
  await Helper.setRevisionTag(siteDefinition);
  await openSharedAdminTool();
  await loginSharedAdminTool();
  await gen.ElementAction(clickloginAsCustLnk);
  await gen.ElementAction(cookieReject);
  await enterCustEmailAdd();
  await gen.ElementAction(clickbcmCustCTA);
});

step(
  'UKPAYMENT Configure Pre-Requisites without setting Cookie and RevisionTag',
  async function () {
    if (siteDefinition.executionContext.platform.toUpperCase() === 'MOBILE') {
      await t.emulateDevice(emulationDevice);
      gauge.message(emulationDevice);
    }
    await gen.ElementAction(cookieReject);
    await openTestOrderUrlUkreg();
  }
);

step(
  'UKPAYMENT Verify that the user is able to select and click the Pay By Link payment method successfully',
  async function () {
    if (cntPBLCta !== '') {
      await gen.ElementAction(clickcntPBLCTA);
      gauge.screenshot();
    } else {
      gauge.message(messages.stepNotApplicable);
    }
    if (await (await t.$(orderConfMsgID)).exists()) {
      assert(matchCondition);
      const confirmurl = await t.currentURL();
      const getOrderNumbertxt = await (await t.$(orderConfMsgID)).text();
      getOrderNumber = getOrderNumbertxt.trim();
      if (confirmurl.includes(CommonData.checkoutConfUrl1)) {
        assert(confirmurl.includes(CommonData.checkoutConfUrl1));
      } else if (confirmurl.includes(CommonData.checkoutConfUrl2)) {
        assert(confirmurl.includes(CommonData.checkoutConfUrl2));
      } else {
        gauge.message(messages.orderNoNotDisplayed);
        assert(!matchCondition);
      }
      gauge.message(getOrderNumber);
      console.log(getOrderNumber);
      gauge.message(messages.successMsg);
    } else {
      gauge.message(messages.errorMsg);
      assert(!matchCondition);
    }
    gauge.screenshot();
  }
);

step(
  'UKPAYMENT Navigate to Order History Page and Click on PBL payment CTA',
  async function () {
    await navToOrdHstPage();
    await srchandClkOrdNumOrOrdDetlnk();
    await gen.ElementAction(clickordHstPBLCTA);
  }
);

step(
  'UKPAYMENT Enter the Payment and Billing details and perform the PBL payment',
  async function () {
    await gen.ElementAction(clickacceptCTA);
    await entCreditCardDetails();
    await entBillingDetails();
    await gen.ElementAction(clickpaybtn);
  }
);

step('UKPAYMENT Verify the PBL Payment Paid Page', async function () {
  await pblPaymentPaidPage();
});

step(
  'UKPAYMENT Verify user able to add virtual set products to cart',
  async function () {
    await addVirtualsetProduct();
    await gen.ElementAction(cookieReject);
    await gen.ElementAction(clickCheckoutBtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step(
  'UKPAYMENT Verify that the user able to add donations <donationAmount> into cart',
  async function (donationAmount) {
    await addDonationFromSharedTool();
    await clickOnDonationCtaOnViewcart(donationAmount);
    await gen.ElementAction(cookieReject);
    await gen.ElementAction(clickCheckoutBtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

step('UKPAYMENT Verify the clearPay CTA Availability', async function () {
  await clearpayCtaAvailability();
});

step(
  'UKPAYMENT Verify that the user able to navigate to SPP page',
  async function () {
    await navigateToSppPage();
  }
);

step(
  'UKPAYMENT Validate the functionality of social sharing icon',
  async function () {
    await socialShareOptions(
      fbSocialShare,
      fbSocialSharePage,
      CommonData.fbTitle
    );
    await socialShareOptions(
      twitterSocialShare,
      twitterSocialSharePage,
      CommonData.twitterTitle
    );
    await socialShareOptions(
      pinterestSocialShare,
      pinterestSocialSharePage,
      CommonData.pinterestTitle
    );
  }
);

step(
  'UKPAYMENT Verify that the user able to navigate to embossing gift page',
  async function () {
    await navigateToEmbossingPage();
  }
);

step(
  'UKPAYMENT Verify that the user able to add embossing gift into their cart',
  async function () {
    await gen.ElementAction(cookieReject);
    await gen.ElementAction(addEmbossingGiftIntoCart);
    await t.reload();
    await gen.ElementAction(clickCheckoutBtn);
    await gen.ElementAction(handleSamplesPage);
    await fullsizesamplepage();
  }
);

// Gift Wrap
step(
  'UKPAYMENT Verify that the user able to Enable the Gift Wrap and enter the Valid/Invalid message <giftMessage>',
  async function (giftMessage) {
    await checkGiftWrap();
    await addGiftMessage(giftMessage);
  }
);

step(
  'UKPAYMENT Verify the Gift Wrap Invalid message and Unselect the Gift Wrap',
  async function () {
    await invalidMessageVerification();
    await cancelGiftMessage();
    await uncheckGiftWrap();
  }
);

step(
  'UKPAYMENT Verify that the user able to Edit the Gift Message and Continue checkout <giftMessage>',
  async function (giftMessage) {
    await editGiftWrapOptions();
    await editGiftMessage(giftMessage);
    await gen.ClickAction(deliveryCheckoutBtnId);
  }
);

step(
  'UKPAYMENT Verify that the Gift Wrap text and its price in checkout pages',
  async function () {
    await gen.ClickAction(shopBagEditBtnId);
    gauge.message('View Cart Page appears');
    await giftWrapTextdAndPrice(
      giftWrapTxtViewCartOrdSummSec,
      giftWrapValViewCartOrdSummSec
    );
    await gen.ClickAction(checkoutBtnID);
    gauge.message('Delivery Page appears');
    await giftWrapTextdAndPrice(
      giftWrapTxtDelPageOrdSummSec,
      giftWrapValDelPageOrdSummSec
    );
    await gen.ClickAction(deliveryCheckoutBtnId);
    gauge.message('Payment Page appears');
    await giftWrapTextdAndPrice(
      giftWrapTxtPayPageOrdSummSec,
      giftWrapValPayPageOrdSummSec
    );
  }
);

step(
  'UKPAYMENT Verify that the Gift Wrap text and its price in Order Confirmation page',
  async function () {
    await giftWrapTextdAndPrice(
      giftWrapTxtOrdConfPageOrdSummSec,
      giftWrapValOrdConfPageOrdSummSec
    );
  }
);

step(
  'UKPAYMENT Verify that the Print page appears with Gift Wrap text and its price in Print page',
  async function () {
    if (siteDefinition.executionContext.platform.toUpperCase() === 'PC') {
      await gen.ClickAction(clickPrintBtnId);
      gauge.message('Print Page appears');
      await giftWrapTextdAndPrice(
        giftWrapTxtPrintPageOrdSummSec,
        giftWrapValPrintPageOrdSummSec
      );
    } else {
      gauge.message('Print Page functionality is not applicable for Mobile');
    }
  }
);

step(
  'UKPAYMENT Verify that the user is able to make payment using Credit Card',
  async function () {
    await placeOrderWithCreditCard();
  }
);

step(
  'UKPAYMENT Verify that the Order History/Details/past_purchase page appears with Gift Wrap text and its price in Order page',
  async function () {
    await navToOrdHstPage();
    gauge.message('Order History/Details/past_purchase Page appears');
    await srchandClkOrdNumOrOrdDetlnk();
    gauge.message('Order number Page appears');
    await giftWrapTextdAndPrice(
      giftWrapTxtOrdHstPageOrdSummSec,
      giftWrapValOrdHstPageOrdSummSec
    );
  }
);

// PBL Automation

async function applyOfferCode(offerCode, offerMessage, delMethod, delType) {
  if (enterOfferCode !== '') {
    await t.write(offerCode, t.into(await t.$(enterOfferCode)));
    gauge.screenshot();
  }
  if (clickOnOfferButton !== '') {
    await t.evaluate(await t.$(clickOnOfferButton), (ele) => ele.click());
    gauge.screenshot();
    var actualValidOfferMsg = await (await t.$(validOfferMessage)).text();
    if (
      actualValidOfferMsg.toUpperCase().search(offerMessage.toUpperCase()) !==
      -1
    ) {
      assert(matchCondition, 'Offer has been applied as expected.');
    } else {
      assert(
        !matchCondition,
        'The offer is not applied which is not expected.'
      );
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
  if (delMethod !== '') {
    expDel = await (await t.$(actualDel)).text();
    expDelType = await (await t.$(actualDelType)).text();
    gauge.screenshot();
    gauge.message(
      'Expected Delivery Type is ' + delType + ' and Price is £0.00'
    );
    gauge.message(
      'Actual Delivery Type is  ' + expDelType + ' and Price is ' + expDel
    );

    if (
      expDelType.toUpperCase().search(delType.toUpperCase()) !== -1 &&
      expDel === '£0.00'
    ) {
      assert(matchCondition, 'Offer has been applied as expected.');
    } else {
      assert(
        !matchCondition,
        'The offer is not applied which is not expected.'
      );
    }
    gauge.screenshot();
  } else {
    gauge.message(messages.stepNotApplicable);
  }
}

step(
  'UKPAYMENT Verify that the user is able to add <offerCode> delivery offer code',
  { continueOnFailure: matchCondition },
  async function (offerCode) {
    if (offerCode === 'STD') {
      await applyOfferCode(
        CommonData.validOfferCode,
        CommonData.validOfferMsg,
        CommonData.expectedDel,
        CommonData.expectedDelType
      );
    } else {
      await applyOfferCode(
        CommonData.validOfferCodeND,
        CommonData.validOfferMsgND,
        CommonData.expectedDel,
        CommonData.expectedDelTypeND
      );
    }
  }
);

step(
  'UKPAYMENT Enter Shipping and International Billing Address Details',
  async function () {
    await gen.ElementAction(intlShippingDetails);
    await gen.ElementAction(intlBillingDetails);
    await gen.ElementAction(clickCheckoutBtn);
    gauge.screenshot();
  }
);

step(
  'UKPAYMENT Verify that the user able to add virtual bundles products into cart',
  async function () {
    await t.goto(siteDefinition.executionContext.url + vbundlesUrl, {
      waitForEvents: ['DOMContentLoaded'],
    });
    await gen.ElementAction(addVirtualBundlesToCart);
    await t.goto(siteDefinition.executionContext.url + viewCartUrl1, {
      waitForEvents: ['DOMContentLoaded'],
    });
    await t.reload();
    gauge.screenshot();
  }
);
